{"javascript":"(function (global, factory) {\r\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\r\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\r\n\t(global = global || self, factory(global.window = global.window || {}));\r\n}(this, (function (exports) { 'use strict';\r\n\r\n\tvar _svgPathExp = /[achlmqstvz]|(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[0-9]/ig,\r\n\t    _scientific = /[\\+\\-]?\\d*\\.?\\d+e[\\+\\-]?\\d+/ig,\r\n\t    _DEG2RAD = Math.PI / 180,\r\n\t    _sin = Math.sin,\r\n\t    _cos = Math.cos,\r\n\t    _abs = Math.abs,\r\n\t    _sqrt = Math.sqrt,\r\n\t    _isNumber = function _isNumber(value) {\r\n\t  return typeof value === \"number\";\r\n\t},\r\n\t    _roundingNum = 1e5,\r\n\t    _round = function _round(value) {\r\n\t  return Math.round(value * _roundingNum) / _roundingNum || 0;\r\n\t};\r\n\tfunction transformRawPath(rawPath, a, b, c, d, tx, ty) {\r\n\t  var j = rawPath.length,\r\n\t      segment,\r\n\t      l,\r\n\t      i,\r\n\t      x,\r\n\t      y;\r\n\r\n\t  while (--j > -1) {\r\n\t    segment = rawPath[j];\r\n\t    l = segment.length;\r\n\r\n\t    for (i = 0; i < l; i += 2) {\r\n\t      x = segment[i];\r\n\t      y = segment[i + 1];\r\n\t      segment[i] = x * a + y * c + tx;\r\n\t      segment[i + 1] = x * b + y * d + ty;\r\n\t    }\r\n\t  }\r\n\r\n\t  rawPath._dirty = 1;\r\n\t  return rawPath;\r\n\t}\r\n\r\n\tfunction arcToSegment(lastX, lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y) {\r\n\t  if (lastX === x && lastY === y) {\r\n\t    return;\r\n\t  }\r\n\r\n\t  rx = _abs(rx);\r\n\t  ry = _abs(ry);\r\n\r\n\t  var angleRad = angle % 360 * _DEG2RAD,\r\n\t      cosAngle = _cos(angleRad),\r\n\t      sinAngle = _sin(angleRad),\r\n\t      PI = Math.PI,\r\n\t      TWOPI = PI * 2,\r\n\t      dx2 = (lastX - x) / 2,\r\n\t      dy2 = (lastY - y) / 2,\r\n\t      x1 = cosAngle * dx2 + sinAngle * dy2,\r\n\t      y1 = -sinAngle * dx2 + cosAngle * dy2,\r\n\t      x1_sq = x1 * x1,\r\n\t      y1_sq = y1 * y1,\r\n\t      radiiCheck = x1_sq / (rx * rx) + y1_sq / (ry * ry);\r\n\r\n\t  if (radiiCheck > 1) {\r\n\t    rx = _sqrt(radiiCheck) * rx;\r\n\t    ry = _sqrt(radiiCheck) * ry;\r\n\t  }\r\n\r\n\t  var rx_sq = rx * rx,\r\n\t      ry_sq = ry * ry,\r\n\t      sq = (rx_sq * ry_sq - rx_sq * y1_sq - ry_sq * x1_sq) / (rx_sq * y1_sq + ry_sq * x1_sq);\r\n\r\n\t  if (sq < 0) {\r\n\t    sq = 0;\r\n\t  }\r\n\r\n\t  var coef = (largeArcFlag === sweepFlag ? -1 : 1) * _sqrt(sq),\r\n\t      cx1 = coef * (rx * y1 / ry),\r\n\t      cy1 = coef * -(ry * x1 / rx),\r\n\t      sx2 = (lastX + x) / 2,\r\n\t      sy2 = (lastY + y) / 2,\r\n\t      cx = sx2 + (cosAngle * cx1 - sinAngle * cy1),\r\n\t      cy = sy2 + (sinAngle * cx1 + cosAngle * cy1),\r\n\t      ux = (x1 - cx1) / rx,\r\n\t      uy = (y1 - cy1) / ry,\r\n\t      vx = (-x1 - cx1) / rx,\r\n\t      vy = (-y1 - cy1) / ry,\r\n\t      temp = ux * ux + uy * uy,\r\n\t      angleStart = (uy < 0 ? -1 : 1) * Math.acos(ux / _sqrt(temp)),\r\n\t      angleExtent = (ux * vy - uy * vx < 0 ? -1 : 1) * Math.acos((ux * vx + uy * vy) / _sqrt(temp * (vx * vx + vy * vy)));\r\n\r\n\t  isNaN(angleExtent) && (angleExtent = PI);\r\n\r\n\t  if (!sweepFlag && angleExtent > 0) {\r\n\t    angleExtent -= TWOPI;\r\n\t  } else if (sweepFlag && angleExtent < 0) {\r\n\t    angleExtent += TWOPI;\r\n\t  }\r\n\r\n\t  angleStart %= TWOPI;\r\n\t  angleExtent %= TWOPI;\r\n\r\n\t  var segments = Math.ceil(_abs(angleExtent) / (TWOPI / 4)),\r\n\t      rawPath = [],\r\n\t      angleIncrement = angleExtent / segments,\r\n\t      controlLength = 4 / 3 * _sin(angleIncrement / 2) / (1 + _cos(angleIncrement / 2)),\r\n\t      ma = cosAngle * rx,\r\n\t      mb = sinAngle * rx,\r\n\t      mc = sinAngle * -ry,\r\n\t      md = cosAngle * ry,\r\n\t      i;\r\n\r\n\t  for (i = 0; i < segments; i++) {\r\n\t    angle = angleStart + i * angleIncrement;\r\n\t    x1 = _cos(angle);\r\n\t    y1 = _sin(angle);\r\n\t    ux = _cos(angle += angleIncrement);\r\n\t    uy = _sin(angle);\r\n\t    rawPath.push(x1 - controlLength * y1, y1 + controlLength * x1, ux + controlLength * uy, uy - controlLength * ux, ux, uy);\r\n\t  }\r\n\r\n\t  for (i = 0; i < rawPath.length; i += 2) {\r\n\t    x1 = rawPath[i];\r\n\t    y1 = rawPath[i + 1];\r\n\t    rawPath[i] = x1 * ma + y1 * mc + cx;\r\n\t    rawPath[i + 1] = x1 * mb + y1 * md + cy;\r\n\t  }\r\n\r\n\t  rawPath[i - 2] = x;\r\n\t  rawPath[i - 1] = y;\r\n\t  return rawPath;\r\n\t}\r\n\r\n\tfunction stringToRawPath(d) {\r\n\t  var a = (d + \"\").replace(_scientific, function (m) {\r\n\t    var n = +m;\r\n\t    return n < 0.0001 && n > -0.0001 ? 0 : n;\r\n\t  }).match(_svgPathExp) || [],\r\n\t      path = [],\r\n\t      relativeX = 0,\r\n\t      relativeY = 0,\r\n\t      twoThirds = 2 / 3,\r\n\t      elements = a.length,\r\n\t      points = 0,\r\n\t      errorMessage = \"ERROR: malformed path: \" + d,\r\n\t      i,\r\n\t      j,\r\n\t      x,\r\n\t      y,\r\n\t      command,\r\n\t      isRelative,\r\n\t      segment,\r\n\t      startX,\r\n\t      startY,\r\n\t      difX,\r\n\t      difY,\r\n\t      beziers,\r\n\t      prevCommand,\r\n\t      flag1,\r\n\t      flag2,\r\n\t      line = function line(sx, sy, ex, ey) {\r\n\t    difX = (ex - sx) / 3;\r\n\t    difY = (ey - sy) / 3;\r\n\t    segment.push(sx + difX, sy + difY, ex - difX, ey - difY, ex, ey);\r\n\t  };\r\n\r\n\t  if (!d || !isNaN(a[0]) || isNaN(a[1])) {\r\n\t    console.log(errorMessage);\r\n\t    return path;\r\n\t  }\r\n\r\n\t  for (i = 0; i < elements; i++) {\r\n\t    prevCommand = command;\r\n\r\n\t    if (isNaN(a[i])) {\r\n\t      command = a[i].toUpperCase();\r\n\t      isRelative = command !== a[i];\r\n\t    } else {\r\n\t      i--;\r\n\t    }\r\n\r\n\t    x = +a[i + 1];\r\n\t    y = +a[i + 2];\r\n\r\n\t    if (isRelative) {\r\n\t      x += relativeX;\r\n\t      y += relativeY;\r\n\t    }\r\n\r\n\t    if (!i) {\r\n\t      startX = x;\r\n\t      startY = y;\r\n\t    }\r\n\r\n\t    if (command === \"M\") {\r\n\t      if (segment) {\r\n\t        if (segment.length < 8) {\r\n\t          path.length -= 1;\r\n\t        } else {\r\n\t          points += segment.length;\r\n\t        }\r\n\t      }\r\n\r\n\t      relativeX = startX = x;\r\n\t      relativeY = startY = y;\r\n\t      segment = [x, y];\r\n\t      path.push(segment);\r\n\t      i += 2;\r\n\t      command = \"L\";\r\n\t    } else if (command === \"C\") {\r\n\t      if (!segment) {\r\n\t        segment = [0, 0];\r\n\t      }\r\n\r\n\t      if (!isRelative) {\r\n\t        relativeX = relativeY = 0;\r\n\t      }\r\n\r\n\t      segment.push(x, y, relativeX + a[i + 3] * 1, relativeY + a[i + 4] * 1, relativeX += a[i + 5] * 1, relativeY += a[i + 6] * 1);\r\n\t      i += 6;\r\n\t    } else if (command === \"S\") {\r\n\t      difX = relativeX;\r\n\t      difY = relativeY;\r\n\r\n\t      if (prevCommand === \"C\" || prevCommand === \"S\") {\r\n\t        difX += relativeX - segment[segment.length - 4];\r\n\t        difY += relativeY - segment[segment.length - 3];\r\n\t      }\r\n\r\n\t      if (!isRelative) {\r\n\t        relativeX = relativeY = 0;\r\n\t      }\r\n\r\n\t      segment.push(difX, difY, x, y, relativeX += a[i + 3] * 1, relativeY += a[i + 4] * 1);\r\n\t      i += 4;\r\n\t    } else if (command === \"Q\") {\r\n\t      difX = relativeX + (x - relativeX) * twoThirds;\r\n\t      difY = relativeY + (y - relativeY) * twoThirds;\r\n\r\n\t      if (!isRelative) {\r\n\t        relativeX = relativeY = 0;\r\n\t      }\r\n\r\n\t      relativeX += a[i + 3] * 1;\r\n\t      relativeY += a[i + 4] * 1;\r\n\t      segment.push(difX, difY, relativeX + (x - relativeX) * twoThirds, relativeY + (y - relativeY) * twoThirds, relativeX, relativeY);\r\n\t      i += 4;\r\n\t    } else if (command === \"T\") {\r\n\t      difX = relativeX - segment[segment.length - 4];\r\n\t      difY = relativeY - segment[segment.length - 3];\r\n\t      segment.push(relativeX + difX, relativeY + difY, x + (relativeX + difX * 1.5 - x) * twoThirds, y + (relativeY + difY * 1.5 - y) * twoThirds, relativeX = x, relativeY = y);\r\n\t      i += 2;\r\n\t    } else if (command === \"H\") {\r\n\t      line(relativeX, relativeY, relativeX = x, relativeY);\r\n\t      i += 1;\r\n\t    } else if (command === \"V\") {\r\n\t      line(relativeX, relativeY, relativeX, relativeY = x + (isRelative ? relativeY - relativeX : 0));\r\n\t      i += 1;\r\n\t    } else if (command === \"L\" || command === \"Z\") {\r\n\t      if (command === \"Z\") {\r\n\t        x = startX;\r\n\t        y = startY;\r\n\t        segment.closed = true;\r\n\t      }\r\n\r\n\t      if (command === \"L\" || _abs(relativeX - x) > 0.5 || _abs(relativeY - y) > 0.5) {\r\n\t        line(relativeX, relativeY, x, y);\r\n\r\n\t        if (command === \"L\") {\r\n\t          i += 2;\r\n\t        }\r\n\t      }\r\n\r\n\t      relativeX = x;\r\n\t      relativeY = y;\r\n\t    } else if (command === \"A\") {\r\n\t      flag1 = a[i + 4];\r\n\t      flag2 = a[i + 5];\r\n\t      difX = a[i + 6];\r\n\t      difY = a[i + 7];\r\n\t      j = 7;\r\n\r\n\t      if (flag1.length > 1) {\r\n\t        if (flag1.length < 3) {\r\n\t          difY = difX;\r\n\t          difX = flag2;\r\n\t          j--;\r\n\t        } else {\r\n\t          difY = flag2;\r\n\t          difX = flag1.substr(2);\r\n\t          j -= 2;\r\n\t        }\r\n\r\n\t        flag2 = flag1.charAt(1);\r\n\t        flag1 = flag1.charAt(0);\r\n\t      }\r\n\r\n\t      beziers = arcToSegment(relativeX, relativeY, +a[i + 1], +a[i + 2], +a[i + 3], +flag1, +flag2, (isRelative ? relativeX : 0) + difX * 1, (isRelative ? relativeY : 0) + difY * 1);\r\n\t      i += j;\r\n\r\n\t      if (beziers) {\r\n\t        for (j = 0; j < beziers.length; j++) {\r\n\t          segment.push(beziers[j]);\r\n\t        }\r\n\t      }\r\n\r\n\t      relativeX = segment[segment.length - 2];\r\n\t      relativeY = segment[segment.length - 1];\r\n\t    } else {\r\n\t      console.log(errorMessage);\r\n\t    }\r\n\t  }\r\n\r\n\t  i = segment.length;\r\n\r\n\t  if (i < 6) {\r\n\t    path.pop();\r\n\t    i = 0;\r\n\t  } else if (segment[0] === segment[i - 2] && segment[1] === segment[i - 1]) {\r\n\t    segment.closed = true;\r\n\t  }\r\n\r\n\t  path.totalPoints = points + i;\r\n\t  return path;\r\n\t}\r\n\tfunction rawPathToString(rawPath) {\r\n\t  if (_isNumber(rawPath[0])) {\r\n\t    rawPath = [rawPath];\r\n\t  }\r\n\r\n\t  var result = \"\",\r\n\t      l = rawPath.length,\r\n\t      sl,\r\n\t      s,\r\n\t      i,\r\n\t      segment;\r\n\r\n\t  for (s = 0; s < l; s++) {\r\n\t    segment = rawPath[s];\r\n\t    result += \"M\" + _round(segment[0]) + \",\" + _round(segment[1]) + \" C\";\r\n\t    sl = segment.length;\r\n\r\n\t    for (i = 2; i < sl; i++) {\r\n\t      result += _round(segment[i++]) + \",\" + _round(segment[i++]) + \" \" + _round(segment[i++]) + \",\" + _round(segment[i++]) + \" \" + _round(segment[i++]) + \",\" + _round(segment[i]) + \" \";\r\n\t    }\r\n\r\n\t    if (segment.closed) {\r\n\t      result += \"z\";\r\n\t    }\r\n\t  }\r\n\r\n\t  return result;\r\n\t}\r\n\r\n\t/*!\r\n\t * CustomEase 3.7.1\r\n\t * https://greensock.com\r\n\t *\r\n\t * @license Copyright 2008-2021, GreenSock. All rights reserved.\r\n\t * Subject to the terms at https://greensock.com/standard-license or for\r\n\t * Club GreenSock members, the agreement issued with that membership.\r\n\t * @author: Jack Doyle, jack@greensock.com\r\n\t*/\r\n\r\n\tvar gsap,\r\n\t    _coreInitted,\r\n\t    _getGSAP = function _getGSAP() {\r\n\t  return gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\r\n\t},\r\n\t    _initCore = function _initCore() {\r\n\t  gsap = _getGSAP();\r\n\r\n\t  if (gsap) {\r\n\t    gsap.registerEase(\"_CE\", CustomEase.create);\r\n\t    _coreInitted = 1;\r\n\t  } else {\r\n\t    console.warn(\"Please gsap.registerPlugin(CustomEase)\");\r\n\t  }\r\n\t},\r\n\t    _bigNum = 1e20,\r\n\t    _round$1 = function _round(value) {\r\n\t  return ~~(value * 1000 + (value < 0 ? -.5 : .5)) / 1000;\r\n\t},\r\n\t    _numExp = /[-+=\\.]*\\d+[\\.e\\-\\+]*\\d*[e\\-\\+]*\\d*/gi,\r\n\t    _needsParsingExp = /[cLlsSaAhHvVtTqQ]/g,\r\n\t    _findMinimum = function _findMinimum(values) {\r\n\t  var l = values.length,\r\n\t      min = _bigNum,\r\n\t      i;\r\n\r\n\t  for (i = 1; i < l; i += 6) {\r\n\t    +values[i] < min && (min = +values[i]);\r\n\t  }\r\n\r\n\t  return min;\r\n\t},\r\n\t    _normalize = function _normalize(values, height, originY) {\r\n\t  if (!originY && originY !== 0) {\r\n\t    originY = Math.max(+values[values.length - 1], +values[1]);\r\n\t  }\r\n\r\n\t  var tx = +values[0] * -1,\r\n\t      ty = -originY,\r\n\t      l = values.length,\r\n\t      sx = 1 / (+values[l - 2] + tx),\r\n\t      sy = -height || (Math.abs(+values[l - 1] - +values[1]) < 0.01 * (+values[l - 2] - +values[0]) ? _findMinimum(values) + ty : +values[l - 1] + ty),\r\n\t      i;\r\n\r\n\t  if (sy) {\r\n\t    sy = 1 / sy;\r\n\t  } else {\r\n\t    sy = -sx;\r\n\t  }\r\n\r\n\t  for (i = 0; i < l; i += 2) {\r\n\t    values[i] = (+values[i] + tx) * sx;\r\n\t    values[i + 1] = (+values[i + 1] + ty) * sy;\r\n\t  }\r\n\t},\r\n\t    _bezierToPoints = function _bezierToPoints(x1, y1, x2, y2, x3, y3, x4, y4, threshold, points, index) {\r\n\t  var x12 = (x1 + x2) / 2,\r\n\t      y12 = (y1 + y2) / 2,\r\n\t      x23 = (x2 + x3) / 2,\r\n\t      y23 = (y2 + y3) / 2,\r\n\t      x34 = (x3 + x4) / 2,\r\n\t      y34 = (y3 + y4) / 2,\r\n\t      x123 = (x12 + x23) / 2,\r\n\t      y123 = (y12 + y23) / 2,\r\n\t      x234 = (x23 + x34) / 2,\r\n\t      y234 = (y23 + y34) / 2,\r\n\t      x1234 = (x123 + x234) / 2,\r\n\t      y1234 = (y123 + y234) / 2,\r\n\t      dx = x4 - x1,\r\n\t      dy = y4 - y1,\r\n\t      d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx),\r\n\t      d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx),\r\n\t      length;\r\n\r\n\t  if (!points) {\r\n\t    points = [{\r\n\t      x: x1,\r\n\t      y: y1\r\n\t    }, {\r\n\t      x: x4,\r\n\t      y: y4\r\n\t    }];\r\n\t    index = 1;\r\n\t  }\r\n\r\n\t  points.splice(index || points.length - 1, 0, {\r\n\t    x: x1234,\r\n\t    y: y1234\r\n\t  });\r\n\r\n\t  if ((d2 + d3) * (d2 + d3) > threshold * (dx * dx + dy * dy)) {\r\n\t    length = points.length;\r\n\r\n\t    _bezierToPoints(x1, y1, x12, y12, x123, y123, x1234, y1234, threshold, points, index);\r\n\r\n\t    _bezierToPoints(x1234, y1234, x234, y234, x34, y34, x4, y4, threshold, points, index + 1 + (points.length - length));\r\n\t  }\r\n\r\n\t  return points;\r\n\t};\r\n\r\n\tvar CustomEase = function () {\r\n\t  function CustomEase(id, data, config) {\r\n\t    _coreInitted || _initCore();\r\n\t    this.id = id;\r\n\t     this.setData(data, config);\r\n\t  }\r\n\r\n\t  var _proto = CustomEase.prototype;\r\n\r\n\t  _proto.setData = function setData(data, config) {\r\n\t    config = config || {};\r\n\t    data = data || \"0,0,1,1\";\r\n\t    var values = data.match(_numExp),\r\n\t        closest = 1,\r\n\t        points = [],\r\n\t        lookup = [],\r\n\t        precision = config.precision || 1,\r\n\t        fast = precision <= 1,\r\n\t        l,\r\n\t        a1,\r\n\t        a2,\r\n\t        i,\r\n\t        inc,\r\n\t        j,\r\n\t        point,\r\n\t        prevPoint,\r\n\t        p;\r\n\t    this.data = data;\r\n\r\n\t    if (_needsParsingExp.test(data) || ~data.indexOf(\"M\") && data.indexOf(\"C\") < 0) {\r\n\t      values = stringToRawPath(data)[0];\r\n\t    }\r\n\r\n\t    l = values.length;\r\n\r\n\t    if (l === 4) {\r\n\t      values.unshift(0, 0);\r\n\t      values.push(1, 1);\r\n\t      l = 8;\r\n\t    } else if ((l - 2) % 6) {\r\n\t      throw \"Invalid CustomEase\";\r\n\t    }\r\n\r\n\t    if (+values[0] !== 0 || +values[l - 2] !== 1) {\r\n\t      _normalize(values, config.height, config.originY);\r\n\t    }\r\n\r\n\t    this.segment = values;\r\n\r\n\t    for (i = 2; i < l; i += 6) {\r\n\t      a1 = {\r\n\t        x: +values[i - 2],\r\n\t        y: +values[i - 1]\r\n\t      };\r\n\t      a2 = {\r\n\t        x: +values[i + 4],\r\n\t        y: +values[i + 5]\r\n\t      };\r\n\t      points.push(a1, a2);\r\n\r\n\t      _bezierToPoints(a1.x, a1.y, +values[i], +values[i + 1], +values[i + 2], +values[i + 3], a2.x, a2.y, 1 / (precision * 200000), points, points.length - 1);\r\n\t    }\r\n\r\n\t    l = points.length;\r\n\r\n\t    for (i = 0; i < l; i++) {\r\n\t      point = points[i];\r\n\t      prevPoint = points[i - 1] || point;\r\n\r\n\t      if ((point.x > prevPoint.x || prevPoint.y !== point.y && prevPoint.x === point.x || point === prevPoint) && point.x <= 1) {\r\n\t        prevPoint.cx = point.x - prevPoint.x;\r\n\t        prevPoint.cy = point.y - prevPoint.y;\r\n\t        prevPoint.n = point;\r\n\t        prevPoint.nx = point.x;\r\n\r\n\t        if (fast && i > 1 && Math.abs(prevPoint.cy / prevPoint.cx - points[i - 2].cy / points[i - 2].cx) > 2) {\r\n\t          fast = 0;\r\n\t        }\r\n\r\n\t        if (prevPoint.cx < closest) {\r\n\t          if (!prevPoint.cx) {\r\n\t            prevPoint.cx = 0.001;\r\n\r\n\t            if (i === l - 1) {\r\n\t              prevPoint.x -= 0.001;\r\n\t              closest = Math.min(closest, 0.001);\r\n\t              fast = 0;\r\n\t            }\r\n\t          } else {\r\n\t            closest = prevPoint.cx;\r\n\t          }\r\n\t        }\r\n\t      } else {\r\n\t        points.splice(i--, 1);\r\n\t        l--;\r\n\t      }\r\n\t    }\r\n\r\n\t    l = 1 / closest + 1 | 0;\r\n\t    inc = 1 / l;\r\n\t    j = 0;\r\n\t    point = points[0];\r\n\r\n\t    if (fast) {\r\n\t      for (i = 0; i < l; i++) {\r\n\t        p = i * inc;\r\n\r\n\t        if (point.nx < p) {\r\n\t          point = points[++j];\r\n\t        }\r\n\r\n\t        a1 = point.y + (p - point.x) / point.cx * point.cy;\r\n\t        lookup[i] = {\r\n\t          x: p,\r\n\t          cx: inc,\r\n\t          y: a1,\r\n\t          cy: 0,\r\n\t          nx: 9\r\n\t        };\r\n\r\n\t        if (i) {\r\n\t          lookup[i - 1].cy = a1 - lookup[i - 1].y;\r\n\t        }\r\n\t      }\r\n\r\n\t      lookup[l - 1].cy = points[points.length - 1].y - a1;\r\n\t    } else {\r\n\t      for (i = 0; i < l; i++) {\r\n\t        if (point.nx < i * inc) {\r\n\t          point = points[++j];\r\n\t        }\r\n\r\n\t        lookup[i] = point;\r\n\t      }\r\n\r\n\t      if (j < points.length - 1) {\r\n\t        lookup[i - 1] = points[points.length - 2];\r\n\t      }\r\n\t    }\r\n\r\n\t    this.ease = function (p) {\r\n\t      var point = lookup[p * l | 0] || lookup[l - 1];\r\n\r\n\t      if (point.nx < p) {\r\n\t        point = point.n;\r\n\t      }\r\n\r\n\t      return point.y + (p - point.x) / point.cx * point.cy;\r\n\t    };\r\n\r\n\t    this.ease.custom = this;\r\n\t    this.id && gsap && gsap.registerEase(this.id, this.ease);\r\n\t    return this;\r\n\t  };\r\n\r\n\t  _proto.getSVGData = function getSVGData(config) {\r\n\t    return CustomEase.getSVGData(this, config);\r\n\t  };\r\n\r\n\t  CustomEase.create = function create(id, data, config) {\r\n\t    return new CustomEase(id, data, config).ease;\r\n\t  };\r\n\r\n\t  CustomEase.register = function register(core) {\r\n\t    gsap = core;\r\n\r\n\t    _initCore();\r\n\t  };\r\n\r\n\t  CustomEase.get = function get(id) {\r\n\t    return gsap.parseEase(id);\r\n\t  };\r\n\r\n\t  CustomEase.getSVGData = function getSVGData(ease, config) {\r\n\t    config = config || {};\r\n\t    var width = config.width || 100,\r\n\t        height = config.height || 100,\r\n\t        x = config.x || 0,\r\n\t        y = (config.y || 0) + height,\r\n\t        e = gsap.utils.toArray(config.path)[0],\r\n\t        a,\r\n\t        slope,\r\n\t        i,\r\n\t        inc,\r\n\t        tx,\r\n\t        ty,\r\n\t        precision,\r\n\t        threshold,\r\n\t        prevX,\r\n\t        prevY;\r\n\r\n\t    if (config.invert) {\r\n\t      height = -height;\r\n\t      y = 0;\r\n\t    }\r\n\r\n\t    if (typeof ease === \"string\") {\r\n\t      ease = gsap.parseEase(ease);\r\n\t    }\r\n\r\n\t    if (ease.custom) {\r\n\t      ease = ease.custom;\r\n\t    }\r\n\r\n\t    if (ease instanceof CustomEase) {\r\n\t      a = rawPathToString(transformRawPath([ease.segment], width, 0, 0, -height, x, y));\r\n\t    } else {\r\n\t      a = [x, y];\r\n\t      precision = Math.max(5, (config.precision || 1) * 200);\r\n\t      inc = 1 / precision;\r\n\t      precision += 2;\r\n\t      threshold = 5 / precision;\r\n\t      prevX = _round$1(x + inc * width);\r\n\t      prevY = _round$1(y + ease(inc) * -height);\r\n\t      slope = (prevY - y) / (prevX - x);\r\n\r\n\t      for (i = 2; i < precision; i++) {\r\n\t        tx = _round$1(x + i * inc * width);\r\n\t        ty = _round$1(y + ease(i * inc) * -height);\r\n\r\n\t        if (Math.abs((ty - prevY) / (tx - prevX) - slope) > threshold || i === precision - 1) {\r\n\t          a.push(prevX, prevY);\r\n\t          slope = (ty - prevY) / (tx - prevX);\r\n\t        }\r\n\r\n\t        prevX = tx;\r\n\t        prevY = ty;\r\n\t      }\r\n\r\n\t      a = \"M\" + a.join(\",\");\r\n\t    }\r\n\r\n\t    e && e.setAttribute(\"d\", a);\r\n\t    return a;\r\n\t  };\r\n\r\n\t  return CustomEase;\r\n\t}();\r\n\t_getGSAP() && gsap.registerPlugin(CustomEase);\r\n\tCustomEase.version = \"3.7.1\";\r\n\r\n\texports.CustomEase = CustomEase;\r\n\texports.default = CustomEase;\r\n\r\n\tObject.defineProperty(exports, '__esModule', { value: true });\r\n\r\n})));\r\n(function (global, factory) {\r\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\r\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\r\n\t(global = global || self, factory(global.window = global.window || {}));\r\n}(this, (function (exports) { 'use strict';\r\n\r\n\t/*!\r\n\t * DrawSVGPlugin 3.7.1\r\n\t * https://greensock.com\r\n\t *\r\n\t * @license Copyright 2008-2021, GreenSock. All rights reserved.\r\n\t * Subject to the terms at https://greensock.com/standard-license or for\r\n\t * Club GreenSock members, the agreement issued with that membership.\r\n\t * @author: Jack Doyle, jack@greensock.com\r\n\t*/\r\n\tvar gsap,\r\n\t    _toArray,\r\n\t    _win,\r\n\t    _isEdge,\r\n\t    _coreInitted,\r\n\t    _windowExists = function _windowExists() {\r\n\t  return typeof window !== \"undefined\";\r\n\t},\r\n\t    _getGSAP = function _getGSAP() {\r\n\t  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\r\n\t},\r\n\t    _numExp = /[-+=\\.]*\\d+[\\.e\\-\\+]*\\d*[e\\-\\+]*\\d*/gi,\r\n\t    _types = {\r\n\t  rect: [\"width\", \"height\"],\r\n\t  circle: [\"r\", \"r\"],\r\n\t  ellipse: [\"rx\", \"ry\"],\r\n\t  line: [\"x2\", \"y2\"]\r\n\t},\r\n\t    _round = function _round(value) {\r\n\t  return Math.round(value * 10000) / 10000;\r\n\t},\r\n\t    _parseNum = function _parseNum(value) {\r\n\t  return parseFloat(value) || 0;\r\n\t},\r\n\t    _parseSingleVal = function _parseSingleVal(value, length) {\r\n\t  var num = _parseNum(value);\r\n\r\n\t  return ~value.indexOf(\"%\") ? num / 100 * length : num;\r\n\t},\r\n\t    _getAttributeAsNumber = function _getAttributeAsNumber(target, attr) {\r\n\t  return _parseNum(target.getAttribute(attr));\r\n\t},\r\n\t    _sqrt = Math.sqrt,\r\n\t    _getDistance = function _getDistance(x1, y1, x2, y2, scaleX, scaleY) {\r\n\t  return _sqrt(Math.pow((_parseNum(x2) - _parseNum(x1)) * scaleX, 2) + Math.pow((_parseNum(y2) - _parseNum(y1)) * scaleY, 2));\r\n\t},\r\n\t    _warn = function _warn(message) {\r\n\t  return console.warn(message);\r\n\t},\r\n\t    _hasNonScalingStroke = function _hasNonScalingStroke(target) {\r\n\t  return target.getAttribute(\"vector-effect\") === \"non-scaling-stroke\";\r\n\t},\r\n\t    _bonusValidated = 1,\r\n\t    _parse = function _parse(value, length, defaultStart) {\r\n\t  var i = value.indexOf(\" \"),\r\n\t      s,\r\n\t      e;\r\n\r\n\t  if (i < 0) {\r\n\t    s = defaultStart !== undefined ? defaultStart + \"\" : value;\r\n\t    e = value;\r\n\t  } else {\r\n\t    s = value.substr(0, i);\r\n\t    e = value.substr(i + 1);\r\n\t  }\r\n\r\n\t  s = _parseSingleVal(s, length);\r\n\t  e = _parseSingleVal(e, length);\r\n\t  return s > e ? [e, s] : [s, e];\r\n\t},\r\n\t    _getLength = function _getLength(target) {\r\n\t  target = _toArray(target)[0];\r\n\r\n\t  if (!target) {\r\n\t    return 0;\r\n\t  }\r\n\r\n\t  var type = target.tagName.toLowerCase(),\r\n\t      style = target.style,\r\n\t      scaleX = 1,\r\n\t      scaleY = 1,\r\n\t      length,\r\n\t      bbox,\r\n\t      points,\r\n\t      prevPoint,\r\n\t      i,\r\n\t      rx,\r\n\t      ry;\r\n\r\n\t  if (_hasNonScalingStroke(target)) {\r\n\t    scaleY = target.getScreenCTM();\r\n\t    scaleX = _sqrt(scaleY.a * scaleY.a + scaleY.b * scaleY.b);\r\n\t    scaleY = _sqrt(scaleY.d * scaleY.d + scaleY.c * scaleY.c);\r\n\t  }\r\n\r\n\t  try {\r\n\t    bbox = target.getBBox();\r\n\t  } catch (e) {\r\n\t    _warn(\"Some browsers won't measure invisible elements (like display:none or masks inside defs).\");\r\n\t  }\r\n\r\n\t  var _ref = bbox || {\r\n\t    x: 0,\r\n\t    y: 0,\r\n\t    width: 0,\r\n\t    height: 0\r\n\t  },\r\n\t      x = _ref.x,\r\n\t      y = _ref.y,\r\n\t      width = _ref.width,\r\n\t      height = _ref.height;\r\n\r\n\t  if ((!bbox || !width && !height) && _types[type]) {\r\n\t    width = _getAttributeAsNumber(target, _types[type][0]);\r\n\t    height = _getAttributeAsNumber(target, _types[type][1]);\r\n\r\n\t    if (type !== \"rect\" && type !== \"line\") {\r\n\t      width *= 2;\r\n\t      height *= 2;\r\n\t    }\r\n\r\n\t    if (type === \"line\") {\r\n\t      x = _getAttributeAsNumber(target, \"x1\");\r\n\t      y = _getAttributeAsNumber(target, \"y1\");\r\n\t      width = Math.abs(width - x);\r\n\t      height = Math.abs(height - y);\r\n\t    }\r\n\t  }\r\n\r\n\t  if (type === \"path\") {\r\n\t    prevPoint = style.strokeDasharray;\r\n\t    style.strokeDasharray = \"none\";\r\n\t    length = target.getTotalLength() || 0;\r\n\t    scaleX !== scaleY && _warn(\"Warning: <path> length cannot be measured when vector-effect is non-scaling-stroke and the element isn't proportionally scaled.\");\r\n\t    length *= (scaleX + scaleY) / 2;\r\n\t    style.strokeDasharray = prevPoint;\r\n\t  } else if (type === \"rect\") {\r\n\t    length = width * 2 * scaleX + height * 2 * scaleY;\r\n\t  } else if (type === \"line\") {\r\n\t    length = _getDistance(x, y, x + width, y + height, scaleX, scaleY);\r\n\t  } else if (type === \"polyline\" || type === \"polygon\") {\r\n\t    points = target.getAttribute(\"points\").match(_numExp) || [];\r\n\t    type === \"polygon\" && points.push(points[0], points[1]);\r\n\t    length = 0;\r\n\r\n\t    for (i = 2; i < points.length; i += 2) {\r\n\t      length += _getDistance(points[i - 2], points[i - 1], points[i], points[i + 1], scaleX, scaleY) || 0;\r\n\t    }\r\n\t  } else if (type === \"circle\" || type === \"ellipse\") {\r\n\t    rx = width / 2 * scaleX;\r\n\t    ry = height / 2 * scaleY;\r\n\t    length = Math.PI * (3 * (rx + ry) - _sqrt((3 * rx + ry) * (rx + 3 * ry)));\r\n\t  }\r\n\r\n\t  return length || 0;\r\n\t},\r\n\t    _getPosition = function _getPosition(target, length) {\r\n\t  target = _toArray(target)[0];\r\n\r\n\t  if (!target) {\r\n\t    return [0, 0];\r\n\t  }\r\n\r\n\t  length || (length = _getLength(target) + 1);\r\n\r\n\t  var cs = _win.getComputedStyle(target),\r\n\t      dash = cs.strokeDasharray || \"\",\r\n\t      offset = _parseNum(cs.strokeDashoffset),\r\n\t      i = dash.indexOf(\",\");\r\n\r\n\t  i < 0 && (i = dash.indexOf(\" \"));\r\n\t  dash = i < 0 ? length : _parseNum(dash.substr(0, i));\r\n\t  dash > length && (dash = length);\r\n\t  return [-offset || 0, dash - offset || 0];\r\n\t},\r\n\t    _initCore = function _initCore() {\r\n\t  if (_windowExists()) {\r\n\t    _win = window;\r\n\t    _coreInitted = gsap = _getGSAP();\r\n\t    _toArray = gsap.utils.toArray;\r\n\t    _isEdge = ((_win.navigator || {}).userAgent || \"\").indexOf(\"Edge\") !== -1;\r\n\t  }\r\n\t};\r\n\r\n\tvar DrawSVGPlugin = {\r\n\t  version: \"3.7.1\",\r\n\t  name: \"drawSVG\",\r\n\t  register: function register(core) {\r\n\t    gsap = core;\r\n\r\n\t    _initCore();\r\n\t  },\r\n\t  init: function init(target, value, tween, index, targets) {\r\n\t    if (!target.getBBox) {\r\n\t      return false;\r\n\t    }\r\n\r\n\t    _coreInitted || _initCore();\r\n\r\n\t    var length = _getLength(target),\r\n\t        start,\r\n\t        end,\r\n\t        cs;\r\n\r\n\t    this._style = target.style;\r\n\t    this._target = target;\r\n\r\n\t    if (value + \"\" === \"true\") {\r\n\t      value = \"0 100%\";\r\n\t    } else if (!value) {\r\n\t      value = \"0 0\";\r\n\t    } else if ((value + \"\").indexOf(\" \") === -1) {\r\n\t      value = \"0 \" + value;\r\n\t    }\r\n\r\n\t    start = _getPosition(target, length);\r\n\t    end = _parse(value, length, start[0]);\r\n\t    this._length = _round(length);\r\n\t    this._dash = _round(start[1] - start[0]);\r\n\t    this._offset = _round(-start[0]);\r\n\t    this._dashPT = this.add(this, \"_dash\", this._dash, _round(end[1] - end[0]));\r\n\t    this._offsetPT = this.add(this, \"_offset\", this._offset, _round(-end[0]));\r\n\r\n\t    if (_isEdge) {\r\n\t      cs = _win.getComputedStyle(target);\r\n\r\n\t      if (cs.strokeLinecap !== cs.strokeLinejoin) {\r\n\t        end = _parseNum(cs.strokeMiterlimit);\r\n\t        this.add(target.style, \"strokeMiterlimit\", end, end + 0.01);\r\n\t      }\r\n\t    }\r\n\r\n\t    this._live = _hasNonScalingStroke(target) || ~(value + \"\").indexOf(\"live\");\r\n\t    this._nowrap = ~(value + \"\").indexOf(\"nowrap\");\r\n\r\n\t    this._props.push(\"drawSVG\");\r\n\r\n\t    return _bonusValidated;\r\n\t  },\r\n\t  render: function render(ratio, data) {\r\n\t    var pt = data._pt,\r\n\t        style = data._style,\r\n\t        length,\r\n\t        lengthRatio,\r\n\t        dash,\r\n\t        offset;\r\n\r\n\t    if (pt) {\r\n\t      if (data._live) {\r\n\t        length = _getLength(data._target);\r\n\r\n\t        if (length !== data._length) {\r\n\t          lengthRatio = length / data._length;\r\n\t          data._length = length;\r\n\r\n\t          if (data._offsetPT) {\r\n\t            data._offsetPT.s *= lengthRatio;\r\n\t            data._offsetPT.c *= lengthRatio;\r\n\t          }\r\n\r\n\t          if (data._dashPT) {\r\n\t            data._dashPT.s *= lengthRatio;\r\n\t            data._dashPT.c *= lengthRatio;\r\n\t          } else {\r\n\t            data._dash *= lengthRatio;\r\n\t          }\r\n\t        }\r\n\t      }\r\n\r\n\t      while (pt) {\r\n\t        pt.r(ratio, pt.d);\r\n\t        pt = pt._next;\r\n\t      }\r\n\r\n\t      dash = data._dash || ratio && ratio !== 1 && 0.0001 || 0;\r\n\t      length = data._length - dash + 0.1;\r\n\t      offset = data._offset;\r\n\t      dash && offset && dash + Math.abs(offset % data._length) > data._length - 0.2 && (offset += offset < 0 ? 0.1 : -0.1) && (length += 0.1);\r\n\t      style.strokeDashoffset = dash ? offset : offset + 0.001;\r\n\t      style.strokeDasharray = length < 0.2 ? \"none\" : dash ? dash + \"px,\" + (data._nowrap ? 999999 : length) + \"px\" : \"0px, 999999px\";\r\n\t    }\r\n\t  },\r\n\t  getLength: _getLength,\r\n\t  getPosition: _getPosition\r\n\t};\r\n\t_getGSAP() && gsap.registerPlugin(DrawSVGPlugin);\r\n\r\n\texports.DrawSVGPlugin = DrawSVGPlugin;\r\n\texports.default = DrawSVGPlugin;\r\n\r\n\tObject.defineProperty(exports, '__esModule', { value: true });\r\n\r\n})));\r\n/* eslint-disable */\r\n\r\n/*!\r\n * imagesLoaded PACKAGED v4.1.4\r\n * JavaScript is all like \"You images are done yet or what?\"\r\n * MIT License\r\n */\r\n\r\n/**\r\n * EvEmitter v1.1.0\r\n * Lil' event emitter\r\n * MIT License\r\n */\r\n\r\n/* jshint unused: true, undef: true, strict: true */\r\n\r\n( function( global, factory ) {\r\n  // universal module definition\r\n  /* jshint strict: false */ /* globals define, module, window */\r\n  if ( typeof define == 'function' && define.amd ) {\r\n    // AMD - RequireJS\r\n    define( 'ev-emitter/ev-emitter',factory );\r\n  } else if ( typeof module == 'object' && module.exports ) {\r\n    // CommonJS - Browserify, Webpack\r\n    module.exports = factory();\r\n  } else {\r\n    // Browser globals\r\n    global.EvEmitter = factory();\r\n  }\r\n\r\n}( typeof window != 'undefined' ? window : this, function() {\r\n\r\n\r\n\r\nfunction EvEmitter() {}\r\n\r\nvar proto = EvEmitter.prototype;\r\n\r\nproto.on = function( eventName, listener ) {\r\n  if ( !eventName || !listener ) {\r\n    return;\r\n  }\r\n  // set events hash\r\n  var events = this._events = this._events || {};\r\n  // set listeners array\r\n  var listeners = events[ eventName ] = events[ eventName ] || [];\r\n  // only add once\r\n  if ( listeners.indexOf( listener ) == -1 ) {\r\n    listeners.push( listener );\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\nproto.once = function( eventName, listener ) {\r\n  if ( !eventName || !listener ) {\r\n    return;\r\n  }\r\n  // add event\r\n  this.on( eventName, listener );\r\n  // set once flag\r\n  // set onceEvents hash\r\n  var onceEvents = this._onceEvents = this._onceEvents || {};\r\n  // set onceListeners object\r\n  var onceListeners = onceEvents[ eventName ] = onceEvents[ eventName ] || {};\r\n  // set flag\r\n  onceListeners[ listener ] = true;\r\n\r\n  return this;\r\n};\r\n\r\nproto.off = function( eventName, listener ) {\r\n  var listeners = this._events && this._events[ eventName ];\r\n  if ( !listeners || !listeners.length ) {\r\n    return;\r\n  }\r\n  var index = listeners.indexOf( listener );\r\n  if ( index != -1 ) {\r\n    listeners.splice( index, 1 );\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\nproto.emitEvent = function( eventName, args ) {\r\n  var listeners = this._events && this._events[ eventName ];\r\n  if ( !listeners || !listeners.length ) {\r\n    return;\r\n  }\r\n  // copy over to avoid interference if .off() in listener\r\n  listeners = listeners.slice(0);\r\n  args = args || [];\r\n  // once stuff\r\n  var onceListeners = this._onceEvents && this._onceEvents[ eventName ];\r\n\r\n  for ( var i=0; i < listeners.length; i++ ) {\r\n    var listener = listeners[i]\r\n    var isOnce = onceListeners && onceListeners[ listener ];\r\n    if ( isOnce ) {\r\n      // remove listener\r\n      // remove before trigger to prevent recursion\r\n      this.off( eventName, listener );\r\n      // unset once flag\r\n      delete onceListeners[ listener ];\r\n    }\r\n    // trigger listener\r\n    listener.apply( this, args );\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\nproto.allOff = function() {\r\n  delete this._events;\r\n  delete this._onceEvents;\r\n};\r\n\r\nreturn EvEmitter;\r\n\r\n}));\r\n\r\n/*!\r\n * imagesLoaded v4.1.4\r\n * JavaScript is all like \"You images are done yet or what?\"\r\n * MIT License\r\n */\r\n\r\n( function( window, factory ) { 'use strict';\r\n  // universal module definition\r\n\r\n  /*global define: false, module: false, require: false */\r\n\r\n  if ( typeof define == 'function' && define.amd ) {\r\n    // AMD\r\n    define( [\r\n      'ev-emitter/ev-emitter'\r\n    ], function( EvEmitter ) {\r\n      return factory( window, EvEmitter );\r\n    });\r\n  } else if ( typeof module == 'object' && module.exports ) {\r\n    // CommonJS\r\n    module.exports = factory(\r\n      window,\r\n      require('ev-emitter')\r\n    );\r\n  } else {\r\n    // browser global\r\n    window.imagesLoaded = factory(\r\n      window,\r\n      window.EvEmitter\r\n    );\r\n  }\r\n\r\n})( typeof window !== 'undefined' ? window : this,\r\n\r\n// --------------------------  factory -------------------------- //\r\n\r\nfunction factory( window, EvEmitter ) {\r\n\r\n\r\n\r\nvar $ = window.jQuery;\r\nvar console = window.console;\r\n\r\n// -------------------------- helpers -------------------------- //\r\n\r\n// extend objects\r\nfunction extend( a, b ) {\r\n  for ( var prop in b ) {\r\n    a[ prop ] = b[ prop ];\r\n  }\r\n  return a;\r\n}\r\n\r\nvar arraySlice = Array.prototype.slice;\r\n\r\n// turn element or nodeList into an array\r\nfunction makeArray( obj ) {\r\n  if ( Array.isArray( obj ) ) {\r\n    // use object if already an array\r\n    return obj;\r\n  }\r\n\r\n  var isArrayLike = typeof obj == 'object' && typeof obj.length == 'number';\r\n  if ( isArrayLike ) {\r\n    // convert nodeList to array\r\n    return arraySlice.call( obj );\r\n  }\r\n\r\n  // array of single index\r\n  return [ obj ];\r\n}\r\n\r\n// -------------------------- imagesLoaded -------------------------- //\r\n\r\n/**\r\n * @param {Array, Element, NodeList, String} elem\r\n * @param {Object or Function} options - if function, use as callback\r\n * @param {Function} onAlways - callback function\r\n */\r\nfunction ImagesLoaded( elem, options, onAlways ) {\r\n  // coerce ImagesLoaded() without new, to be new ImagesLoaded()\r\n  if ( !( this instanceof ImagesLoaded ) ) {\r\n    return new ImagesLoaded( elem, options, onAlways );\r\n  }\r\n  // use elem as selector string\r\n  var queryElem = elem;\r\n  if ( typeof elem == 'string' ) {\r\n    queryElem = document.querySelectorAll( elem );\r\n  }\r\n  // bail if bad element\r\n  if ( !queryElem ) {\r\n    console.error( 'Bad element for imagesLoaded ' + ( queryElem || elem ) );\r\n    return;\r\n  }\r\n\r\n  this.elements = makeArray( queryElem );\r\n  this.options = extend( {}, this.options );\r\n  // shift arguments if no options set\r\n  if ( typeof options == 'function' ) {\r\n    onAlways = options;\r\n  } else {\r\n    extend( this.options, options );\r\n  }\r\n\r\n  if ( onAlways ) {\r\n    this.on( 'always', onAlways );\r\n  }\r\n\r\n  this.getImages();\r\n\r\n  if ( $ ) {\r\n    // add jQuery Deferred object\r\n    this.jqDeferred = new $.Deferred();\r\n  }\r\n\r\n  // HACK check async to allow time to bind listeners\r\n  setTimeout( this.check.bind( this ) );\r\n}\r\n\r\nImagesLoaded.prototype = Object.create( EvEmitter.prototype );\r\n\r\nImagesLoaded.prototype.options = {};\r\n\r\nImagesLoaded.prototype.getImages = function() {\r\n  this.images = [];\r\n\r\n  // filter & find items if we have an item selector\r\n  this.elements.forEach( this.addElementImages, this );\r\n};\r\n\r\n/**\r\n * @param {Node} element\r\n */\r\nImagesLoaded.prototype.addElementImages = function( elem ) {\r\n  // filter siblings\r\n  if ( elem.nodeName == 'IMG' ) {\r\n    this.addImage( elem );\r\n  }\r\n  // get background image on element\r\n  if ( this.options.background === true ) {\r\n    this.addElementBackgroundImages( elem );\r\n  }\r\n\r\n  // find children\r\n  // no non-element nodes, #143\r\n  var nodeType = elem.nodeType;\r\n  if ( !nodeType || !elementNodeTypes[ nodeType ] ) {\r\n    return;\r\n  }\r\n  var childImgs = elem.querySelectorAll('img');\r\n  // concat childElems to filterFound array\r\n  for ( var i=0; i < childImgs.length; i++ ) {\r\n    var img = childImgs[i];\r\n    this.addImage( img );\r\n  }\r\n\r\n  // get child background images\r\n  if ( typeof this.options.background == 'string' ) {\r\n    var children = elem.querySelectorAll( this.options.background );\r\n    for ( i=0; i < children.length; i++ ) {\r\n      var child = children[i];\r\n      this.addElementBackgroundImages( child );\r\n    }\r\n  }\r\n};\r\n\r\nvar elementNodeTypes = {\r\n  1: true,\r\n  9: true,\r\n  11: true\r\n};\r\n\r\nImagesLoaded.prototype.addElementBackgroundImages = function( elem ) {\r\n  var style = getComputedStyle( elem );\r\n  if ( !style ) {\r\n    // Firefox returns null if in a hidden iframe https://bugzil.la/548397\r\n    return;\r\n  }\r\n  // get url inside url(\"...\")\r\n  var reURL = /url\\((['\"])?(.*?)\\1\\)/gi;\r\n  var matches = reURL.exec( style.backgroundImage );\r\n  while ( matches !== null ) {\r\n    var url = matches && matches[2];\r\n    if ( url ) {\r\n      this.addBackground( url, elem );\r\n    }\r\n    matches = reURL.exec( style.backgroundImage );\r\n  }\r\n};\r\n\r\n/**\r\n * @param {Image} img\r\n */\r\nImagesLoaded.prototype.addImage = function( img ) {\r\n  var loadingImage = new LoadingImage( img );\r\n  this.images.push( loadingImage );\r\n};\r\n\r\nImagesLoaded.prototype.addBackground = function( url, elem ) {\r\n  var background = new Background( url, elem );\r\n  this.images.push( background );\r\n};\r\n\r\nImagesLoaded.prototype.check = function() {\r\n  var _this = this;\r\n  this.progressedCount = 0;\r\n  this.hasAnyBroken = false;\r\n  // complete if no images\r\n  if ( !this.images.length ) {\r\n    this.complete();\r\n    return;\r\n  }\r\n\r\n  function onProgress( image, elem, message ) {\r\n    // HACK - Chrome triggers event before object properties have changed. #83\r\n    setTimeout( function() {\r\n      _this.progress( image, elem, message );\r\n    });\r\n  }\r\n\r\n  this.images.forEach( function( loadingImage ) {\r\n    loadingImage.once( 'progress', onProgress );\r\n    loadingImage.check();\r\n  });\r\n};\r\n\r\nImagesLoaded.prototype.progress = function( image, elem, message ) {\r\n  this.progressedCount++;\r\n  this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;\r\n  // progress event\r\n  this.emitEvent( 'progress', [ this, image, elem ] );\r\n  if ( this.jqDeferred && this.jqDeferred.notify ) {\r\n    this.jqDeferred.notify( this, image );\r\n  }\r\n  // check if completed\r\n  if ( this.progressedCount == this.images.length ) {\r\n    this.complete();\r\n  }\r\n\r\n  if ( this.options.debug && console ) {\r\n    console.log( 'progress: ' + message, image, elem );\r\n  }\r\n};\r\n\r\nImagesLoaded.prototype.complete = function() {\r\n  var eventName = this.hasAnyBroken ? 'fail' : 'done';\r\n  this.isComplete = true;\r\n  this.emitEvent( eventName, [ this ] );\r\n  this.emitEvent( 'always', [ this ] );\r\n  if ( this.jqDeferred ) {\r\n    var jqMethod = this.hasAnyBroken ? 'reject' : 'resolve';\r\n    this.jqDeferred[ jqMethod ]( this );\r\n  }\r\n};\r\n\r\n// --------------------------  -------------------------- //\r\n\r\nfunction LoadingImage( img ) {\r\n  this.img = img;\r\n}\r\n\r\nLoadingImage.prototype = Object.create( EvEmitter.prototype );\r\n\r\nLoadingImage.prototype.check = function() {\r\n  // If complete is true and browser supports natural sizes,\r\n  // try to check for image status manually.\r\n  var isComplete = this.getIsImageComplete();\r\n  if ( isComplete ) {\r\n    // report based on naturalWidth\r\n    this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );\r\n    return;\r\n  }\r\n\r\n  // If none of the checks above matched, simulate loading on detached element.\r\n  this.proxyImage = new Image();\r\n  this.proxyImage.addEventListener( 'load', this );\r\n  this.proxyImage.addEventListener( 'error', this );\r\n  // bind to image as well for Firefox. #191\r\n  this.img.addEventListener( 'load', this );\r\n  this.img.addEventListener( 'error', this );\r\n  this.proxyImage.src = this.img.src;\r\n};\r\n\r\nLoadingImage.prototype.getIsImageComplete = function() {\r\n  // check for non-zero, non-undefined naturalWidth\r\n  // fixes Safari+InfiniteScroll+Masonry bug infinite-scroll#671\r\n  return this.img.complete && this.img.naturalWidth;\r\n};\r\n\r\nLoadingImage.prototype.confirm = function( isLoaded, message ) {\r\n  this.isLoaded = isLoaded;\r\n  this.emitEvent( 'progress', [ this, this.img, message ] );\r\n};\r\n\r\n// ----- events ----- //\r\n\r\n// trigger specified handler for event type\r\nLoadingImage.prototype.handleEvent = function( event ) {\r\n  var method = 'on' + event.type;\r\n  if ( this[ method ] ) {\r\n    this[ method ]( event );\r\n  }\r\n};\r\n\r\nLoadingImage.prototype.onload = function() {\r\n  this.confirm( true, 'onload' );\r\n  this.unbindEvents();\r\n};\r\n\r\nLoadingImage.prototype.onerror = function() {\r\n  this.confirm( false, 'onerror' );\r\n  this.unbindEvents();\r\n};\r\n\r\nLoadingImage.prototype.unbindEvents = function() {\r\n  this.proxyImage.removeEventListener( 'load', this );\r\n  this.proxyImage.removeEventListener( 'error', this );\r\n  this.img.removeEventListener( 'load', this );\r\n  this.img.removeEventListener( 'error', this );\r\n};\r\n\r\n// -------------------------- Background -------------------------- //\r\n\r\nfunction Background( url, element ) {\r\n  this.url = url;\r\n  this.element = element;\r\n  this.img = new Image();\r\n}\r\n\r\n// inherit LoadingImage prototype\r\nBackground.prototype = Object.create( LoadingImage.prototype );\r\n\r\nBackground.prototype.check = function() {\r\n  this.img.addEventListener( 'load', this );\r\n  this.img.addEventListener( 'error', this );\r\n  this.img.src = this.url;\r\n  // check if image is already complete\r\n  var isComplete = this.getIsImageComplete();\r\n  if ( isComplete ) {\r\n    this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );\r\n    this.unbindEvents();\r\n  }\r\n};\r\n\r\nBackground.prototype.unbindEvents = function() {\r\n  this.img.removeEventListener( 'load', this );\r\n  this.img.removeEventListener( 'error', this );\r\n};\r\n\r\nBackground.prototype.confirm = function( isLoaded, message ) {\r\n  this.isLoaded = isLoaded;\r\n  this.emitEvent( 'progress', [ this, this.element, message ] );\r\n};\r\n\r\n// -------------------------- jQuery -------------------------- //\r\n\r\nImagesLoaded.makeJQueryPlugin = function( jQuery ) {\r\n  jQuery = jQuery || window.jQuery;\r\n  if ( !jQuery ) {\r\n    return;\r\n  }\r\n  // set local variable\r\n  $ = jQuery;\r\n  // $().imagesLoaded()\r\n  $.fn.imagesLoaded = function( options, callback ) {\r\n    var instance = new ImagesLoaded( this, options, callback );\r\n    return instance.jqDeferred.promise( $(this) );\r\n  };\r\n};\r\n// try making plugin\r\nImagesLoaded.makeJQueryPlugin();\r\n\r\n// --------------------------  -------------------------- //\r\n\r\nreturn ImagesLoaded;\r\n\r\n});(function (global, factory) {\r\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\r\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\r\n\t(global = global || self, factory(global.window = global.window || {}));\r\n}(this, (function (exports) { 'use strict';\r\n\r\n\t/*!\r\n\t * ScrollToPlugin 3.7.1\r\n\t * https://greensock.com\r\n\t *\r\n\t * @license Copyright 2008-2021, GreenSock. All rights reserved.\r\n\t * Subject to the terms at https://greensock.com/standard-license or for\r\n\t * Club GreenSock members, the agreement issued with that membership.\r\n\t * @author: Jack Doyle, jack@greensock.com\r\n\t*/\r\n\tvar gsap,\r\n\t    _coreInitted,\r\n\t    _window,\r\n\t    _docEl,\r\n\t    _body,\r\n\t    _toArray,\r\n\t    _config,\r\n\t    _windowExists = function _windowExists() {\r\n\t  return typeof window !== \"undefined\";\r\n\t},\r\n\t    _getGSAP = function _getGSAP() {\r\n\t  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\r\n\t},\r\n\t    _isString = function _isString(value) {\r\n\t  return typeof value === \"string\";\r\n\t},\r\n\t    _isFunction = function _isFunction(value) {\r\n\t  return typeof value === \"function\";\r\n\t},\r\n\t    _max = function _max(element, axis) {\r\n\t  var dim = axis === \"x\" ? \"Width\" : \"Height\",\r\n\t      scroll = \"scroll\" + dim,\r\n\t      client = \"client\" + dim;\r\n\t  return element === _window || element === _docEl || element === _body ? Math.max(_docEl[scroll], _body[scroll]) - (_window[\"inner\" + dim] || _docEl[client] || _body[client]) : element[scroll] - element[\"offset\" + dim];\r\n\t},\r\n\t    _buildGetter = function _buildGetter(e, axis) {\r\n\t  var p = \"scroll\" + (axis === \"x\" ? \"Left\" : \"Top\");\r\n\r\n\t  if (e === _window) {\r\n\t    if (e.pageXOffset != null) {\r\n\t      p = \"page\" + axis.toUpperCase() + \"Offset\";\r\n\t    } else {\r\n\t      e = _docEl[p] != null ? _docEl : _body;\r\n\t    }\r\n\t  }\r\n\r\n\t  return function () {\r\n\t    return e[p];\r\n\t  };\r\n\t},\r\n\t    _clean = function _clean(value, index, target, targets) {\r\n\t  _isFunction(value) && (value = value(index, target, targets));\r\n\r\n\t  if (typeof value !== \"object\") {\r\n\t    return _isString(value) && value !== \"max\" && value.charAt(1) !== \"=\" ? {\r\n\t      x: value,\r\n\t      y: value\r\n\t    } : {\r\n\t      y: value\r\n\t    };\r\n\t  } else if (value.nodeType) {\r\n\t    return {\r\n\t      y: value,\r\n\t      x: value\r\n\t    };\r\n\t  } else {\r\n\t    var result = {},\r\n\t        p;\r\n\r\n\t    for (p in value) {\r\n\t      result[p] = p !== \"onAutoKill\" && _isFunction(value[p]) ? value[p](index, target, targets) : value[p];\r\n\t    }\r\n\r\n\t    return result;\r\n\t  }\r\n\t},\r\n\t    _getOffset = function _getOffset(element, container) {\r\n\t  element = _toArray(element)[0];\r\n\r\n\t  if (!element || !element.getBoundingClientRect) {\r\n\t    return console.warn(\"scrollTo target doesn't exist. Using 0\") || {\r\n\t      x: 0,\r\n\t      y: 0\r\n\t    };\r\n\t  }\r\n\r\n\t  var rect = element.getBoundingClientRect(),\r\n\t      isRoot = !container || container === _window || container === _body,\r\n\t      cRect = isRoot ? {\r\n\t    top: _docEl.clientTop - (_window.pageYOffset || _docEl.scrollTop || _body.scrollTop || 0),\r\n\t    left: _docEl.clientLeft - (_window.pageXOffset || _docEl.scrollLeft || _body.scrollLeft || 0)\r\n\t  } : container.getBoundingClientRect(),\r\n\t      offsets = {\r\n\t    x: rect.left - cRect.left,\r\n\t    y: rect.top - cRect.top\r\n\t  };\r\n\r\n\t  if (!isRoot && container) {\r\n\t    offsets.x += _buildGetter(container, \"x\")();\r\n\t    offsets.y += _buildGetter(container, \"y\")();\r\n\t  }\r\n\r\n\t  return offsets;\r\n\t},\r\n\t    _parseVal = function _parseVal(value, target, axis, currentVal, offset) {\r\n\t  return !isNaN(value) && typeof value !== \"object\" ? parseFloat(value) - offset : _isString(value) && value.charAt(1) === \"=\" ? parseFloat(value.substr(2)) * (value.charAt(0) === \"-\" ? -1 : 1) + currentVal - offset : value === \"max\" ? _max(target, axis) - offset : Math.min(_max(target, axis), _getOffset(value, target)[axis] - offset);\r\n\t},\r\n\t    _initCore = function _initCore() {\r\n\t  gsap = _getGSAP();\r\n\r\n\t  if (_windowExists() && gsap && document.body) {\r\n\t    _window = window;\r\n\t    _body = document.body;\r\n\t    _docEl = document.documentElement;\r\n\t    _toArray = gsap.utils.toArray;\r\n\t    gsap.config({\r\n\t      autoKillThreshold: 7\r\n\t    });\r\n\t    _config = gsap.config();\r\n\t    _coreInitted = 1;\r\n\t  }\r\n\t};\r\n\r\n\tvar ScrollToPlugin = {\r\n\t  version: \"3.7.1\",\r\n\t  name: \"scrollTo\",\r\n\t  rawVars: 1,\r\n\t  register: function register(core) {\r\n\t    gsap = core;\r\n\r\n\t    _initCore();\r\n\t  },\r\n\t  init: function init(target, value, tween, index, targets) {\r\n\t    _coreInitted || _initCore();\r\n\t    var data = this,\r\n\t        snapType = gsap.getProperty(target, \"scrollSnapType\");\r\n\t    data.isWin = target === _window;\r\n\t    data.target = target;\r\n\t    data.tween = tween;\r\n\t    value = _clean(value, index, target, targets);\r\n\t    data.vars = value;\r\n\t    data.autoKill = !!value.autoKill;\r\n\t    data.getX = _buildGetter(target, \"x\");\r\n\t    data.getY = _buildGetter(target, \"y\");\r\n\t    data.x = data.xPrev = data.getX();\r\n\t    data.y = data.yPrev = data.getY();\r\n\r\n\t    if (snapType && snapType !== \"none\") {\r\n\t      data.snap = 1;\r\n\t      data.snapInline = target.style.scrollSnapType;\r\n\t      target.style.scrollSnapType = \"none\";\r\n\t    }\r\n\r\n\t    if (value.x != null) {\r\n\t      data.add(data, \"x\", data.x, _parseVal(value.x, target, \"x\", data.x, value.offsetX || 0), index, targets);\r\n\r\n\t      data._props.push(\"scrollTo_x\");\r\n\t    } else {\r\n\t      data.skipX = 1;\r\n\t    }\r\n\r\n\t    if (value.y != null) {\r\n\t      data.add(data, \"y\", data.y, _parseVal(value.y, target, \"y\", data.y, value.offsetY || 0), index, targets);\r\n\r\n\t      data._props.push(\"scrollTo_y\");\r\n\t    } else {\r\n\t      data.skipY = 1;\r\n\t    }\r\n\t  },\r\n\t  render: function render(ratio, data) {\r\n\t    var pt = data._pt,\r\n\t        target = data.target,\r\n\t        tween = data.tween,\r\n\t        autoKill = data.autoKill,\r\n\t        xPrev = data.xPrev,\r\n\t        yPrev = data.yPrev,\r\n\t        isWin = data.isWin,\r\n\t        snap = data.snap,\r\n\t        snapInline = data.snapInline,\r\n\t        x,\r\n\t        y,\r\n\t        yDif,\r\n\t        xDif,\r\n\t        threshold;\r\n\r\n\t    while (pt) {\r\n\t      pt.r(ratio, pt.d);\r\n\t      pt = pt._next;\r\n\t    }\r\n\r\n\t    x = isWin || !data.skipX ? data.getX() : xPrev;\r\n\t    y = isWin || !data.skipY ? data.getY() : yPrev;\r\n\t    yDif = y - yPrev;\r\n\t    xDif = x - xPrev;\r\n\t    threshold = _config.autoKillThreshold;\r\n\r\n\t    if (data.x < 0) {\r\n\t      data.x = 0;\r\n\t    }\r\n\r\n\t    if (data.y < 0) {\r\n\t      data.y = 0;\r\n\t    }\r\n\r\n\t    if (autoKill) {\r\n\t      if (!data.skipX && (xDif > threshold || xDif < -threshold) && x < _max(target, \"x\")) {\r\n\t        data.skipX = 1;\r\n\t      }\r\n\r\n\t      if (!data.skipY && (yDif > threshold || yDif < -threshold) && y < _max(target, \"y\")) {\r\n\t        data.skipY = 1;\r\n\t      }\r\n\r\n\t      if (data.skipX && data.skipY) {\r\n\t        tween.kill();\r\n\t        data.vars.onAutoKill && data.vars.onAutoKill.apply(tween, data.vars.onAutoKillParams || []);\r\n\t      }\r\n\t    }\r\n\r\n\t    if (isWin) {\r\n\t      _window.scrollTo(!data.skipX ? data.x : x, !data.skipY ? data.y : y);\r\n\t    } else {\r\n\t      data.skipY || (target.scrollTop = data.y);\r\n\t      data.skipX || (target.scrollLeft = data.x);\r\n\t    }\r\n\r\n\t    if (snap && (ratio === 1 || ratio === 0)) {\r\n\t      y = target.scrollTop;\r\n\t      x = target.scrollLeft;\r\n\t      snapInline ? target.style.scrollSnapType = snapInline : target.style.removeProperty(\"scroll-snap-type\");\r\n\t      target.scrollTop = y + 1;\r\n\t      target.scrollLeft = x + 1;\r\n\t      target.scrollTop = y;\r\n\t      target.scrollLeft = x;\r\n\t    }\r\n\r\n\t    data.xPrev = data.x;\r\n\t    data.yPrev = data.y;\r\n\t  },\r\n\t  kill: function kill(property) {\r\n\t    var both = property === \"scrollTo\";\r\n\r\n\t    if (both || property === \"scrollTo_x\") {\r\n\t      this.skipX = 1;\r\n\t    }\r\n\r\n\t    if (both || property === \"scrollTo_y\") {\r\n\t      this.skipY = 1;\r\n\t    }\r\n\t  }\r\n\t};\r\n\tScrollToPlugin.max = _max;\r\n\tScrollToPlugin.getOffset = _getOffset;\r\n\tScrollToPlugin.buildGetter = _buildGetter;\r\n\t_getGSAP() && gsap.registerPlugin(ScrollToPlugin);\r\n\r\n\texports.ScrollToPlugin = ScrollToPlugin;\r\n\texports.default = ScrollToPlugin;\r\n\r\n\tObject.defineProperty(exports, '__esModule', { value: true });\r\n\r\n})));\r\n","css":"","html":"","input":"css","output":["[4[47"]}